<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco FoodCalc - Diet Optimizer</title>
    <style>
        /* Basic Styles */
        body { font-family: sans-serif; margin: 20px; }
        h1 { color: #333; display: inline-block; margin: 0; }
        
        /* Version Top Right */
        #version-display { float: right; font-size: 0.9em; color: #555; }
        
        .food-list { width: 100%; border-collapse: collapse; margin-top: 20px; }
        .food-list th, .food-list td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        .food-list th { background-color: #f2f2f2; }
        
        /* Highlighting Rows */
        .row-favorite { background-color: #fffacd; }
        .row-worst { background-color: #ffcccc; }
        .row-attention { 
            background-color: #ffe4b2;
            border: 2px solid #ffaa00;
        }
        
        /* Status and Tag Styles */
        .status-select { padding: 5px; border-radius: 4px; }

        /* Custom Tag Display */
        .status-tag { 
            padding: 5px 8px; 
            border-radius: 4px; 
            font-weight: bold; 
            display: inline-block;
            white-space: nowrap;
        }
        .status-tag.favorite { background-color: #f0ad4e; color: white; }
        .status-tag.worst { background-color: #d9534f; color: white; }

        /* Footer Style */
        footer { margin-top: 50px; font-size: 0.8em; color: #666; }
        
        #food-search-input {
            padding: 10px;
            font-size: 16px;
            width: 50%;
            margin-top: 10px;
        }
        #stomach-size-input {
            padding: 5px;
            width: 80px;
            text-align: right;
        }
        
        /* Centralization of Selects de Tags */
        #global-tags-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        #fav-worst-selects {
            display: flex;
            justify-content: space-between;
            width: 600px;
            max-width: 100%;
        }
        #fav-worst-selects select {
            padding: 8px;
            font-size: 14px;
            width: 280px;
        }

        /* Layout for Diet Section */
        #diet-suggestion-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        #suggested-foods-list {
            flex: 1;
            min-width: 50%;
        }
        #nutrition-pie-chart-container {
            width: 300px;
        }
    </style>
</head>
<body>

    <div id="version-display">
        Version 0.1<br>
        Last update: <span id="last-update-date"></span>
    </div>
    
    <h1>Eco FoodCalc - Diet Optimizer</h1>
    
    <p>Current Session Status: <span id="user-session"></span></p> 
    <button onclick="resetPreferences()" style="padding: 5px 10px; background-color: #f44336; color: white; border: none; cursor: pointer; border-radius: 4px;">Reset All Preferences</button>
    
    <div style="margin-top: 10px; margin-bottom: 20px;">
        <button onclick="exportPreferences()" style="padding: 5px 10px; background-color: #007bff; color: white; border: none; cursor: pointer; border-radius: 4px; margin-right: 10px;">Export Preferences</button>
        <label for="import-file-input" style="padding: 5px 10px; background-color: #28a745; color: white; border: none; cursor: pointer; border-radius: 4px;">Import Preferences</label>
        <input type="file" id="import-file-input" accept=".json" onchange="importPreferences(event)" style="display: none;">
    </div>

    <p>This tool helps maximize your **Nutrition Bonus** for faster skill point gain in Eco.</p>
    
    <div style="margin-bottom: 20px;">
        <label for="stomach-size-input">Stomach Size (Calories): </label>
        <input type="number" id="stomach-size-input" value="3000" min="100" onchange="updateStomachSize(this.value)">
    </div>
    
    <h2>Suggested Diet Optimization</h2>
    <div style="margin-bottom: 20px;">
        <label>
            <input type="checkbox" id="strict-taste-toggle" checked onchange="saveStrictTastePreference(this.checked)">
            Exclude Bad and Horrible foods from diet suggestion.
        </label>
    </div>
    <div id="diet-suggestion-container">
        <div id="suggested-foods-list">
            <p>Processing optimization algorithm...</p>
        </div>
        <div id="nutrition-pie-chart-container">
            </div>
    </div>
    <hr>
    
    <div id="food-container"></div> 

    <footer>
        <hr>
        <p>Created by CrazySpy.</p>
    </footer>

    <script>
        const FOOD_SOURCE_URL = 'foodsource.json';
        const STOMACH_SIZE_DEFAULT = 3000;
        
        const FOOD_STATUS_KEYS = {
            'REMOVE_FROM_LIST': 'Remove from list', 
            'SELECT_STATUS': '--- SELECT STATUS ---', 
            'DELICIOUS': 'Delicious', 
            'GOOD': 'Good', 
            'OK': 'Ok', 
            'BAD': 'Bad', 
            'HORRIBLE': 'Horrible'
        };
        
        const PIE_COLORS = { 'Carbs': '#3498db', 'Fat': '#2ecc71', 'Protein': '#e74c3c', 'Vitamins': '#f1c40f' };

        const STATUS_OPTIONS = Object.values(FOOD_STATUS_KEYS);
        const DATA_STORAGE_KEY = 'eco_food_preferences';
        const STOMACH_SIZE_KEY = 'eco_stomach_size';
        const FAVORITE_KEY = 'eco_favorite_food';
        const WORST_KEY = 'eco_worst_food';
        const STRICT_TASTE_KEY = 'eco_strict_taste';
        
        let foodData = [];
        let userPreferences = {};
        let stomachSize = STOMACH_SIZE_DEFAULT;
        let favoriteFood = '';
        let worstFood = '';
        let strictTasteMode = true; 
        
        const sessionElement = document.getElementById('user-session');
        const container = document.getElementById('food-container');


        // --- SECTION 1: DATA PERSISTENCE & LOADERS ---

        function saveUserPreferences() {
            localStorage.setItem(DATA_STORAGE_KEY, JSON.stringify(userPreferences));
        }

        function saveStomachSize() {
            localStorage.setItem(STOMACH_SIZE_KEY, stomachSize);
        }
        
        function saveGlobalTag(tagKey, foodName) {
            localStorage.setItem(tagKey, foodName);
        }

        function loadUserPreferences() {
            const storedData = localStorage.getItem(DATA_STORAGE_KEY);
            if (storedData) {
                userPreferences = JSON.parse(storedData);
                sessionElement.textContent = 'Preferences loaded.';
            } else {
                foodData.forEach(item => {
                    const name = item.Food_Name;
                    userPreferences[name] = { status: FOOD_STATUS_KEYS.REMOVE_FROM_LIST };
                });
                saveUserPreferences();
                sessionElement.textContent = 'New session initialized (All set to Remove from list).';
            }
        }

        function loadGlobalTags() {
            favoriteFood = localStorage.getItem(FAVORITE_KEY) || '';
            worstFood = localStorage.getItem(WORST_KEY) || '';
        }
        
        function loadStomachSize() {
            const storedSize = localStorage.getItem(STOMACH_SIZE_KEY);
            if (storedSize) {
                stomachSize = parseInt(storedSize);
            }
            const inputElement = document.getElementById('stomach-size-input');
            if(inputElement) inputElement.value = stomachSize;
        }

        function loadStrictTastePreference() {
            const storedStrict = localStorage.getItem(STRICT_TASTE_KEY);
            if (storedStrict !== null) {
                strictTasteMode = storedStrict === 'true';
            }
            const toggleElement = document.getElementById('strict-taste-toggle');
            if (toggleElement) {
                toggleElement.checked = strictTasteMode;
            }
        }

        // --- EXPORT/IMPORT FUNCTIONS ---
        function exportPreferences() {
            const exportData = {
                preferences: localStorage.getItem(DATA_STORAGE_KEY),
                stomachSize: localStorage.getItem(STOMACH_SIZE_KEY),
                favoriteFood: localStorage.getItem(FAVORITE_KEY),
                worstFood: localStorage.getItem(WORST_KEY),
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'EcoFoodCalc_Config.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importPreferences(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);

                    if (importedData.preferences) localStorage.setItem(DATA_STORAGE_KEY, importedData.preferences);
                    if (importedData.stomachSize) localStorage.setItem(STOMACH_SIZE_KEY, importedData.stomachSize);
                    if (importedData.favoriteFood) localStorage.setItem(FAVORITE_KEY, importedData.favoriteFood);
                    if (importedData.worstFood) localStorage.setItem(WORST_KEY, importedData.worstFood);
                    
                    alert('Import successful! Reloading application.');
                    window.location.reload();

                } catch (error) {
                    alert('Error processing file. Please ensure it is a valid EcoFoodCalc JSON format.');
                    console.error('Import error:', error);
                }
            };
            reader.readAsText(file);
        }

        // --- SECTION 2: ALGORITHMIC CORE (Utility and Calculation) ---

        /**
         * Calculates the Balance Modifier (0.5x to 2.0x).
         */
        function calculateBalanceModifier(analysis) {
             const nutrients = [analysis.Carbs, analysis.Fat, analysis.Protein, analysis.Vitamins];
             const avg = 25;
             const variance = nutrients.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / 4;
             const stdDev = Math.sqrt(variance);
             
             let modifier = 2.0 - (stdDev / 10);
             if (modifier < 0.5) modifier = 0.5;
             
             return `${modifier.toFixed(2)}x`;
        }

        /**
         * Calculates the standard deviation (inverse of balance) for a given nutrient set.
         */
        function getBalanceScore(nutrients) {
            const sum = nutrients.Carbs + nutrients.Fat + nutrients.Protein + nutrients.Vitamins;
            if (sum === 0) return Infinity;

            const distribution = [
                (nutrients.Carbs / sum) * 100,
                (nutrients.Fat / sum) * 100,
                (nutrients.Protein / sum) * 100,
                (nutrients.Vitamins / sum) * 100
            ];

            const avg = 25;
            const variance = distribution.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / 4;
            
            // Retorna a variação (o desvio padrão ao quadrado), que é o que queremos minimizar.
            // Quanto menor o número, melhor o balanço.
            return variance;
        }

        /**
         * Renders the nutrient distribution legend/analysis (Simplified Text View).
         */
        function renderPieChart(analysis) {
            const chartContainer = document.getElementById('nutrition-pie-chart-container');
            const data = [
                { label: 'Carbs', percent: analysis.Carbs, color: PIE_COLORS.Carbs },
                { label: 'Fat', percent: analysis.Fat, color: PIE_COLORS.Fat },
                { label: 'Protein', percent: analysis.Protein, color: PIE_COLORS.Protein },
                { label: 'Vitamins', percent: analysis.Vitamins, color: PIE_COLORS.Vitamins }
            ];
            
            const balanceModifier = calculateBalanceModifier(analysis);

            chartContainer.innerHTML = `
                <h4 style="text-align: center;">Nutrient Distribution</h4>
                <div style="font-size: 1.1em; text-align: center; margin-bottom: 10px;">
                    <strong>Balance Modifier: ${balanceModifier}</strong>
                </div>
                <div style="width: 100%; height: 120px;">
                    <ul style="list-style-type: none; padding: 0;">
                        ${data.map(slice => 
                            `<li style="font-weight: ${slice.percent > 28 || slice.percent < 22 ? 'bold' : 'normal'};">
                                <span style="display: inline-block; width: 10px; height: 10px; background-color: ${slice.color}; margin-right: 4px;"></span> 
                                ${slice.label}: ${slice.percent.toFixed(1)}% (Goal: 25%)
                            </li>`
                        ).join('')}
                    </ul>
                </div>`;
        }


        /**
         * Finds the optimal diet (The corrected Knapsack/Greedy approach using balance score).
         */
        function findOptimalDiet(availableFoods) {
            
            // 1. Aplicar a Pontuação de Gosto para a Otimização
            const processedFoods = availableFoods.map(food => {
                let tasteScore = 0;
                const status = userPreferences[food.Food_Name].status;

                if (status === FOOD_STATUS_KEYS.DELICIOUS) {
                    tasteScore = 3;
                } else if (status === FOOD_STATUS_KEYS.GOOD) {
                    tasteScore = 2;
                } else if (status === FOOD_STATUS_KEYS.OK) {
                    tasteScore = 1;
                }
                
                if (food.Food_Name === favoriteFood) {
                    tasteScore = 4; // Prioridade máxima
                }

                return {
                    name: food.Food_Name,
                    calories: food.Official_Calories_Game,
                    carbs: food.Carbs, fat: food.Fat, protein: food.Protein, vitamins: food.Vitamins,
                    priority: tasteScore, // Gosto
                };
            });

            let currentCalories = 0;
            let currentNutrients = { Carbs: 0, Fat: 0, Protein: 0, Vitamins: 0 };
            let suggestedDiet = [];

            // 2. Algoritmo Guloso Otimizado: Escolhe o item que *melhorará* o balanço total.
            while (currentCalories < stomachSize) {
                
                let bestFoodToEat = null;
                // Inicializa o melhor score de balanço com o balanço atual
                let bestBalanceScore = getBalanceScore(currentNutrients); 
                let bestFoodToEatScore = -Infinity; // Pontuação do item

                for (const food of processedFoods) {
                    if (currentCalories + food.calories > stomachSize) continue;
                    if (food.carbs + food.fat + food.protein + food.vitamins === 0) continue;

                    // Simula o estado futuro do estômago se esta comida for adicionada
                    const futureNutrients = {
                        Carbs: currentNutrients.Carbs + food.carbs,
                        Fat: currentNutrients.Fat + food.fat,
                        Protein: currentNutrients.Protein + food.protein,
                        Vitamins: currentNutrients.Vitamins + food.vitamins,
                    };

                    const futureBalanceScore = getBalanceScore(futureNutrients);
                    
                    // Score = (Quanto o balanço melhora) + (Fator de Gosto para desempate)
                    // Queremos minimizar o futureBalanceScore.
                    let balanceImprovement = bestBalanceScore - futureBalanceScore;

                    // Adiciona peso de Gosto: prioriza Delicious/Favorite se o impacto no balanço for neutro
                    let finalScore = balanceImprovement + (food.priority * 0.001); // 0.001 é um fator pequeno para desempate

                    // Se a adição for neutra (balanceImprovement ≈ 0) ou melhorar o balanço, E for o melhor item até agora:
                    // Usamos > 0.0001 para garantir que a melhora é real ou pelo menos o gosto é melhor que 0.
                    if (finalScore > bestFoodToEatScore) {
                        bestFoodToEatScore = finalScore;
                        bestFoodToEat = food;
                        bestBalanceScore = futureBalanceScore; // Atualiza o melhor balanço encontrado para o próximo loop
                    }
                }

                if (!bestFoodToEat) {
                    break; // Não cabe mais nada ou não há nada que melhore o balanço
                }

                // Consome a melhor comida encontrada
                currentCalories += bestFoodToEat.calories;
                currentNutrients.Carbs += bestFoodToEat.carbs;
                currentNutrients.Fat += bestFoodToEat.fat;
                currentNutrients.Protein += bestFoodToEat.protein;
                currentNutrients.Vitamins += bestFoodToEat.vitamins;
                
                // Contabiliza porções
                const existingEntry = suggestedDiet.find(e => e.name === bestFoodToEat.name);
                if (existingEntry) {
                    existingEntry.count++;
                } else {
                    suggestedDiet.push({ name: bestFoodToEat.name, count: 1, calories: bestFoodToEat.calories });
                }
            }

            // 4. Análise Final
            const finalTotalNutrients = currentNutrients.Carbs + currentNutrients.Fat + currentNutrients.Protein + currentNutrients.Vitamins;

            const dietAnalysis = {
                Carbs: (finalTotalNutrients > 0 ? (currentNutrients.Carbs / finalTotalNutrients) : 0) * 100,
                Fat: (finalTotalNutrients > 0 ? (currentNutrients.Fat / finalTotalNutrients) : 0) * 100,
                Protein: (finalTotalNutrients > 0 ? (currentNutrients.Protein / finalTotalNutrients) : 0) * 100,
                Vitamins: (finalTotalNutrients > 0 ? (currentNutrients.Vitamins / finalTotalNutrients) : 0) * 100,
                TotalCalories: currentCalories
            };
            
            // --- Renderizar Resultados ---
            
            const listContainer = document.getElementById('suggested-foods-list');

            if (suggestedDiet.length === 0) {
                 listContainer.innerHTML = '<p style="color: red;">Could not find a diet plan within your constraints.</p>';
                 document.getElementById('nutrition-pie-chart-container').innerHTML = '';
                 return;
            }

            listContainer.innerHTML = '<h4>Suggested Meal Plan:</h4>';
            listContainer.innerHTML += `
                <p><strong>Goal Calories: ${stomachSize} Kcal</strong></p>
                <p><strong>Total Diet Calories: ${dietAnalysis.TotalCalories} Kcal (Remaining: ${stomachSize - dietAnalysis.TotalCalories} Kcal)</strong></p>
                <ul style="list-style-type: none; padding: 0;">
                    ${suggestedDiet.map(entry => `<li>- ${entry.count}x ${entry.name} (${entry.calories} Kcal each)</li>`).join('')}
                </ul>
            `;
            
            renderPieChart(dietAnalysis);
        }

        // --- SECTION 3: MAIN FLOW CONTROL ---

        function calculateSuggestedDiet() {
            const listContainer = document.getElementById('suggested-foods-list');
            const chartContainer = document.getElementById('nutrition-pie-chart-container');

            const availableFoods = foodData.filter(item => {
                const name = item.Food_Name;
                const prefs = userPreferences[name];
                
                if (!prefs) return false; 
                
                // Exclusão Obrigatória
                if (prefs.status === FOOD_STATUS_KEYS.REMOVE_FROM_LIST || 
                    prefs.status === FOOD_STATUS_KEYS.SELECT_STATUS || 
                    name === worstFood) { 
                    return false;
                }

                if (item.Official_Calories_Game > stomachSize) {
                    return false;
                }
                
                // Exclusão Condicional (Toggle de Gosto)
                if (document.getElementById('strict-taste-toggle').checked) { // Check the current state of the toggle
                    if (prefs.status === FOOD_STATUS_KEYS.HORRIBLE || prefs.status === FOOD_STATUS_KEYS.BAD) {
                         return false;
                    }
                } else {
                    if (prefs.status === FOOD_STATUS_KEYS.HORRIBLE) {
                         return false;
                    }
                }
                
                return true; 
            });

            if (availableFoods.length === 0) {
                listContainer.innerHTML = '<p style="color: red;">No suitable foods available based on your current evaluation.</p>';
                chartContainer.innerHTML = '';
                return;
            }

            findOptimalDiet(availableFoods);
        }


        function renderFoodLists() {
            const allFoods = [...foodData];
            const evaluatedFoods = allFoods.filter(item => {
                const prefs = userPreferences[item.Food_Name];
                return prefs && prefs.status !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST;
            });
            const unevaluatedFoods = allFoods.filter(item => {
                const prefs = userPreferences[item.Food_Name];
                return !prefs || prefs.status === FOOD_STATUS_KEYS.REMOVE_FROM_LIST;
            });
            
            calculateSuggestedDiet(); 
            
            let html = renderGlobalTagSelectors(evaluatedFoods);

            html += '<h2>1. Your Evaluated Foods</h2>';
            html += `<p>Manage the foods you have already tried. (Evaluated Foods: ${evaluatedFoods.length})</p>`;
            html += renderEvaluatedTable(evaluatedFoods);

            html += '<hr style="margin: 40px 0;">';
            
            html += '<h2>2. Evaluate New Foods</h2>';
            html += '<p>Search or select a food to add it to your evaluated list and set its status.</p>';
            html += renderSearchInterface(unevaluatedFoods);

            container.innerHTML = html;
        }

        // --- SECTION 4: USER INTERACTION HANDLERS ---

        function updateStomachSize(newValue) {
            stomachSize = parseInt(newValue) || STOMACH_SIZE_DEFAULT;
            saveStomachSize();
            renderFoodLists();
        }

        function setGlobalTag(selectElement, tagType) {
            const foodName = selectElement.value;
            
            if (tagType === 'favorite') {
                favoriteFood = foodName;
                saveGlobalTag(FAVORITE_KEY, foodName);
            } else if (tagType === 'worst') {
                worstFood = foodName;
                saveGlobalTag(WORST_KEY, foodName);
            }

            if (!foodName) {
                if (tagType === 'favorite') favoriteFood = '';
                if (tagType === 'worst') worstFood = '';
                saveGlobalTag(tagType === 'favorite' ? FAVORITE_KEY : WORST_KEY, '');
            }

            renderFoodLists();
        }

        function updateFoodStatus(foodName, newStatus) {
            const oldStatus = userPreferences[foodName].status;
            userPreferences[foodName].status = newStatus;
            
            const isMovingList = (oldStatus === FOOD_STATUS_KEYS.REMOVE_FROM_LIST && newStatus !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST);

            saveUserPreferences();
            
            if (isMovingList || newStatus === FOOD_STATUS_KEYS.REMOVE_FROM_LIST) {
                 renderFoodLists(); 
            } else {
                calculateSuggestedDiet();
                const evaluatedFoods = foodData.filter(item => userPreferences[item.Food_Name] && userPreferences[item.Food_Name].status !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST);
                const evaluatedTableContainer = document.querySelector('#food-container .food-list');
                if (evaluatedTableContainer) {
                    evaluatedTableContainer.outerHTML = renderEvaluatedTable(evaluatedFoods);
                } else {
                    renderFoodLists(); 
                }
            }
        }
        
        function addFoodToEvaluatedList(foodName) {
            const itemKey = foodData.find(item => item.Food_Name === foodName)?.Food_Name;
            
            if (!itemKey || userPreferences[itemKey].status !== FOOD_STATUS_KEYS.REMOVE_FROM_LIST) {
                alert(`Food "${foodName}" not found or already evaluated.`);
                document.getElementById('food-search-input').value = "";
                return;
            }

            const defaultNewStatus = FOOD_STATUS_KEYS.SELECT_STATUS; 

            userPreferences[itemKey].status = defaultNewStatus;
            
            saveUserPreferences();
            renderFoodLists();
            
            document.getElementById('food-search-input').value = "";
        }

        function resetPreferences() {
            if (confirm('Are you sure you want to delete ALL saved preferences (food status, tags, and stomach size)? This action cannot be undone.')) {
                localStorage.clear();
                window.location.reload();
            }
        }

        // --- SECTION 5: INITIALIZATION ---

        function loadUserPreferences() {
            const storedData = localStorage.getItem(DATA_STORAGE_KEY);

            if (storedData) {
                userPreferences = JSON.parse(storedData);
                sessionElement.textContent = 'Preferences loaded.';
            } else {
                foodData.forEach(item => {
                    const name = item.Food_Name;
                    userPreferences[name] = { status: FOOD_STATUS_KEYS.REMOVE_FROM_LIST };
                });
                saveUserPreferences();
                sessionElement.textContent = 'New session initialized (All set to Remove from list).';
            }
        }
        
        function loadStrictTastePreference() {
            const storedStrict = localStorage.getItem(STRICT_TASTE_KEY);
            if (storedStrict !== null) {
                strictTasteMode = storedStrict === 'true';
            }
            const toggleElement = document.getElementById('strict-taste-toggle');
            if (toggleElement) {
                toggleElement.checked = strictTasteMode;
            }
        }

        function loadStomachSize() {
            const storedSize = localStorage.getItem(STOMACH_SIZE_KEY);
            if (storedSize) {
                stomachSize = parseInt(storedSize);
            }
            const inputElement = document.getElementById('stomach-size-input');
            if(inputElement) inputElement.value = stomachSize;
        }

        function loadGlobalTags() {
            favoriteFood = localStorage.getItem(FAVORITE_KEY) || '';
            worstFood = localStorage.getItem(WORST_KEY) || '';
        }

        async function fetchLastCommitDate() {
            const dateElement = document.getElementById('last-update-date');
            dateElement.textContent = 'fetching commit data...';

            const repoOwner = 'Crazy-Spy';
            const repoName = 'EcoFoodCalc';
            const branchName = 'main'; 
            const apiURL = `https://api.github.com/repos/${repoOwner}/${repoName}/commits/${branchName}`;

            try {
                const cachedDate = localStorage.getItem('last-commit-date');
                const etag = localStorage.getItem('last-commit-etag') || '';

                const response = fetch(apiURL, { headers: { 'If-None-Match': etag } });

                response.then(res => {
                    if (res.status === 304) {
                        if (cachedDate) {
                            dateElement.textContent = cachedDate;
                            return;
                        }
                    }
                    if (!res.ok) {
                        throw new Error(`GitHub API error: ${res.status} ${res.statusText}`);
                    }
                    return res.json();
                }).then(data => {
                    const lastCommitDate = new Date(data.commit.author.date);
                    const formattedDate = lastCommitDate.toLocaleDateString('pt-BR', {
                        day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false
                    });
                    dateElement.textContent = formattedDate;
                    localStorage.setItem('last-commit-date', formattedDate);
                    localStorage.setItem('last-commit-etag', response.headers.get('ETag'));
                }).catch(error => {
                    console.error("Failed to fetch GitHub commit date:", error);
                    dateElement.textContent = 'Error fetching date.';
                });

            } catch (error) {
                console.error("Critical error in fetchLastCommitDate:", error);
                dateElement.textContent = 'Error fetching date.';
            }
        }

        async function initApp() {
            
            sessionElement.textContent = 'Checking preferences...';
            container.innerHTML = 'Loading food data...';

            try {
                const response = await fetch(FOOD_SOURCE_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                foodData = await response.json();

                loadUserPreferences();
                loadStomachSize();
                loadGlobalTags();
                loadStrictTastePreference(); 

                renderFoodLists(); 
                
            } catch (error) {
                console.error("Error loading or processing JSON:", error);
                container.innerHTML = `<p style="color: red;">Error loading ${FOOD_SOURCE_URL}. Please check the file name and format.</p>`;
                sessionElement.textContent = 'Failed to start session.';
            }

            document.getElementById('last-update-date').textContent = new Date().toLocaleDateString('en-US');
            fetchLastCommitDate();
        }


        // Initialize the application at the end of the script
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
